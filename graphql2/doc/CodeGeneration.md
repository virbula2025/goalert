The code generation in GoAlert is driven by a "Schema-First" workflow. Instead of writing the API logic by hand, the developers define the data structures and queries in a GraphQL schema, and a suite of tools generates the Go code to match.

Based on the `gen.go` file and the surrounding architecture, here is exactly how the code is generated:

### 1. The Orchestrator (`gen.go`)
The `gen.go` file uses Go's build-in `//go:generate` directives. When a developer runs `go generate ./...`, the following sequence is executed:

1.  **Cleanup**: It deletes existing generated files (`mapconfig.go`, `maplimit.go`) to ensure a clean state.
2.  **GQLGen**: It runs `go tool gqlgen -config gqlgen.yml`. This is the primary engine that maps the GraphQL schema to Go code.
3.  **Custom Tooling**:
    * `configparams`: Generates `mapconfig.go`, which maps internal system configuration variables into the GraphQL API.
    * `limitapigen`: Generates `maplimit.go`, which exposes system limits (like max number of alerts) through the API.
4.  **Formatting**: It runs `goimports` to ensure the newly generated files have the correct imports and are properly formatted.

### 2. The Configuration (`gqlgen.yml`)
This file (referenced in `gen.go`) acts as the map between the GraphQL world and the Go world. It tells the generator:
* Where the schema files are located.
* Where to output the generated code (`generated.go`).
* **Type Mapping**: It maps GraphQL types (like `Alert`) to existing Go structs (like `github.com/target/goalert/alert.Alert`). This prevents the generator from creating redundant structs and allows the API to use the core business logic models directly.

### 3. Key Generated Output Files
The generation process results in three primary types of files:

* **`generated.go`**: This contains the "Executable Schema." It handles the high-level orchestration, such as parsing incoming JSON, checking query complexity, and calling the appropriate "Resolver" methods.
* **`models_gen.go`**: This contains Go structs for any GraphQL types that *weren't* mapped to existing code in `gqlgen.yml`. This usually includes "Input" objects (like `CreateAlertInput`) and "Enums" (like `UserRole`).
* **Specialty Mappers**: `mapconfig.go` and `maplimit.go` are generated by GoAlert-specific tools to ensure that the API and the internal system settings stay in sync without manual updates.

### 4. Marshalling (Custom Scalars)
For types that don't have a default representation in GraphQL (like specific Time formats), manual "Marshaller" functions are written in files like `isotimestamp.go`. The generated code then calls these functions to convert Go `time.Time` objects into ISO-formatted strings and back again.

### 5. The Resolver Interface
The most important result of the generation is the `ResolverRoot` interface. The generator creates the interface, and the developer implements it in the `graphqlapp` package. If the schema changes, the interface changes, and the Go compiler will throw an error until the developer updates the implementation logic to match the new schema.